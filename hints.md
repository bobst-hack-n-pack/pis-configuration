ðŸ”¥ **HINT 1** - 20:30 - Rotary encoder details

ðŸ”¥ **HINT 2:** - 21:15 - Send data
**Equipment dashboard **will allow you to validate that you are sending the 2 minimal data properly to the Cloud: `machinespeed`, `totaloutputunitcount` 

**Energy Consumption **will allow you to validate that you are sending one of the optionnal energy related value: `totalworkingenergy` 

**Performance Live **will allow you to validate that you are sending some of the optionnal machine related event: `startProducing`, `stopProducing`, `newJob`, `stopJob`

ðŸ”¥ **HINT 3:** - 21:15 - Energy Sensor INA219: https://miliohm.com/how-to-use-ina219-current-sensor-with-arduino-and-make-diy-wattmeter-with-it/

ðŸ”¥ **HINT 4 MachineEvent extra specifications:** - 22:15
You should respect the API specification for the format in those images.
![Job event](https://github.com/user-attachments/assets/a48a45c2-026f-4985-b6ee-d55a8ee6931a)
![Production event](https://github.com/user-attachments/assets/65dcc8e2-09b4-453d-af77-ec9ce4e56127)

:construction: Also any production that is less than 3 minutes will be considered a `micro-stop` and therefore not visible in the Live Performance page. :eyes: 


ðŸ”¥ **HINT 5 Rotary Encoder details:** - 23:45
We have provided you with the [Rotary Encoder](https://www.amazon.fr/RUNCCI-YUN-Encodeur-potentiom%C3%A8tre-num%C3%A9rique-Commutateur/dp/B09SG3HF9N/ref=sr_1_2?dib=eyJ2IjoiMSJ9.pF-8-Rh11DeRzU98l3FqIRkdMihREdpTxCDyU06LaJRUrOAzPZcaw1IFSvUQojYiYs1NN1hbsdIR5kY173UTBZZWUzVIg83QYOCoPcAm-wSNn0M4Rntg_KV76AHgi7OVpTt_VHrqp0wEZ3DeMHVzbUTIqc1fXUS55BuDmg6LoU9FERq6I1SyfdHIvMisPu11_PJCeMw4ml2G8NZ_LiVs-mKfqsLpIPX9nMhQ8pysNunVqViav89DHOFYFnnEIUURyRWwNZKDQUFJWlXSe50z1yU49b319a506r9Lk4qIbsw.vVstqWYq0WEp0OCq59kN7FSh_2gjmalakHvgxDm59Zk&dib_tag=se&keywords=rotary+encoder&nsdOptOutParam=true&qid=1733006245&sr=8-2) EC11 using the `gpiozero` library, the best approach is to use `gpiozero`â€™s built-in `RotaryEncoder` [class](https://gpiozero.readthedocs.io/en/stable/api_input.html#rotaryencoder), which is designed to handle the pulses generated by rotary encoders. The EC11 rotary encoder typically has two signal pins (A and B) that create quadrature signals, allowing you to determine both the direction and the number of steps and a third one (SW) to detect the switch press.

### EC11 Rotary Encoder Overview:
- **Pins**: The EC11 encoder generally has 5 pins: two are for power (`+` and `GND`), and three for functionality:
  1. **SW**: Button switch press (pressing the knob)
  2. **A and B**: Quadrature outputs that detect the rotation direction and steps

### Pin Connections for EC11:
1. **Power (VCC)**: Connect to `3.3V` or `5V` on the Raspberry Pi.
2. **Ground (GND)**: Connect to GND on the Raspberry Pi.
3. **Signal A**: Connect to a GPIO pin (e.g., GPIO17).
4. **Signal B**: Connect to another GPIO pin (e.g., GPIO18).
5. **SW**: connects to another GPIO pin for detecting button presses (e.g., GPIO21).

### Using `gpiozero` for EC11
Here's a Python script that uses the `gpiozero` library to interact with the EC11 rotary encoder:

```python
from gpiozero import RotaryEncoder, Button
from signal import pause

# Pins connected to A and B of the rotary encoder
rotary_encoder = RotaryEncoder(a=17, b=18, max_steps=0)

# Button pin (connected to the SW pin of the encoder)
button = Button(27)  # Connect to GPIO pin 21 if you want to use the button press

# Callback to handle rotation events
def rotated():
    if rotary_encoder.steps > 0:
        print(f"Rotated clockwise: Current step: {rotary_encoder.steps}")
    else:
        print(f"Rotated counter-clockwise: Current step: {rotary_encoder.steps}")

# Callback to handle button press
def button_pressed():
    print("Button pressed!")

# Register event handlers
rotary_encoder.when_rotated = rotated
button.when_pressed = button_pressed

print("Rotary Encoder is ready. Rotate to see events, press button if connected.")
pause()  # Keeps the program running to listen for events
```

ðŸ”¥ **HINT 6 Telemetry data:** - 01:00
[send-telemetry-to-azure-iothub-working-example.py](send-telemetry-to-azure-iothub-working-example.py)

**Little precision about the machine events:**
For the machine Event we expect a list of message: `[message]``

```python
async def send_machine_event(self, event_type, job_id, total_output_unit_count, machine_speed):
    message = {
        "type": event_type,
        "equipmentId": self.machine_id,
        "jobId": job_id,
        "totalOutputUnitCount": total_output_unit_count,
        "machineSpeed": machine_speed,
        "timestamp": datetime.datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%S.%fZ"),
    }
    await self.__send_message([message], "MachineEvent")
```

ðŸ”¥ **HINT 7 MachineEvent data:** - 02:00
[send-machineEvent-to-azure-iothub-working-example.py](send-machineEvent-to-azure-iothub-working-example.py)

__Here is an example of code that will send data for the whole precedent day. Start and stoping production every 10 minutes.
This is just an example, it might contains errors and it is not a reference for clean code.__



---

**Other stuff to do**
Lots of teams choose to do an HMI or Mobile App, keep in mind that the main value of it would be to be able to control the machine and maybe have some extra dashboard that we don't have in the cloud.

Also, remember, that the best order of achievement is:
- Build machine
- Collect at least machinespeed, totaloutputunitcount, and totalworkingenergy
- Send those to the Azure IoT Hub of Bobst Connect
- Send machineEvent that are coherent
- Create an HMI / or anything alike that allow you to control the machine and maybe get extra insight for an operator of the machine like a notification in case of failure, sound in your computer?, ... think outside of what we provided...
- Create coherent scenario of production? A job can last x minutes or hours or days and have different sequence of production
- ....
